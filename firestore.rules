rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Allow authenticated users to read and write to canvas shapes
    match /canvas/{canvasId}/shapes/{shapeId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.createdBy
        && validateShapeData();
      allow update: if request.auth != null 
        && (resource.data.isLocked == false || resource.data.lockedBy == request.auth.uid || isUnlockingOnly())
        && validateShapeUpdate();
      allow delete: if request.auth != null 
        && (resource.data.isLocked == false || resource.data.lockedBy == request.auth.uid);
      
      // ðŸ’¬ Comments on shapes
      match /comments/{commentId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null 
          && request.auth.uid == request.resource.data.authorId
          && validateCommentData();
        allow update: if request.auth != null 
          && request.auth.uid == resource.data.authorId; // Only author can edit
        allow delete: if request.auth != null 
          && request.auth.uid == resource.data.authorId; // Only author can delete
      }
    }
    
    // Validation functions
    function isUnlockingOnly() {
      // Allow anyone to unlock a shape if they're ONLY changing lock-related fields
      // This enables "Clear All Locks" functionality
      let existing = resource.data;
      let updated = request.resource.data;
      return updated.isLocked == false && 
             updated.lockedBy == null &&
             // All other fields must remain unchanged
             updated.type == existing.type &&
             updated.x == existing.x &&
             updated.y == existing.y &&
             updated.width == existing.width &&
             updated.height == existing.height &&
             updated.fill == existing.fill &&
             updated.createdBy == existing.createdBy &&
             updated.createdAt == existing.createdAt &&
             updated.lastModifiedBy == existing.lastModifiedBy &&
             updated.lastModifiedAt == existing.lastModifiedAt;
    }
    
    function validateShapeData() {
      let data = request.resource.data;
      return data.keys().hasAll(['type', 'x', 'y', 'width', 'height', 'fill', 'createdBy', 'createdAt', 'lastModifiedBy', 'lastModifiedAt', 'isLocked']) &&
             data.type in ['rectangle', 'circle', 'triangle'] &&
             data.x is number && data.x >= 0 && data.x <= 5000 &&
             data.y is number && data.y >= 0 && data.y <= 5000 &&
             data.width is number && data.width > 0 && data.width <= 1000 &&
             data.height is number && data.height > 0 && data.height <= 1000 &&
             data.fill is string && data.fill.size() > 0 &&
             data.createdBy is string && data.createdBy.size() > 0 &&
             data.lastModifiedBy is string && data.lastModifiedBy.size() > 0 &&
             data.isLocked is bool &&
             // Timestamps - allow serverTimestamp() sentinel or actual timestamp
             (data.createdAt == request.time || data.createdAt is timestamp) &&
             (data.lastModifiedAt == request.time || data.lastModifiedAt is timestamp) &&
             // Optional text field validation
             (!data.keys().hasAny(['text']) || data.text is string) &&
             (!data.keys().hasAny(['textColor']) || data.textColor is string) &&
             (!data.keys().hasAny(['fontSize']) || (data.fontSize is number && data.fontSize > 0)) &&
             // Locking fields validation  
             (!data.keys().hasAny(['lockedBy']) || data.lockedBy == null || data.lockedBy is string) &&
             (!data.keys().hasAny(['lockedByName']) || data.lockedByName == null || data.lockedByName is string) &&
             (!data.keys().hasAny(['lockedByColor']) || data.lockedByColor == null || data.lockedByColor is string) &&
             // ðŸŽ„ Christmas texture (optional)
             (!data.keys().hasAny(['texture']) || data.texture is string);
    }
    
    function validateShapeUpdate() {
      let existing = resource.data;
      let updated = request.resource.data;
      // Protect immutable fields from being changed
      return updated.type == existing.type &&
             updated.createdBy == existing.createdBy &&
             updated.createdAt == existing.createdAt;
      // Allow all other fields to be updated (x, y, width, height, fill, text, isLocked, etc.)
    }
    
    function validateCommentData() {
      let data = request.resource.data;
      return data.keys().hasAll(['shapeId', 'text', 'authorId', 'authorName', 'createdAt']) &&
             data.shapeId is string && data.shapeId.size() > 0 &&
             data.text is string && data.text.size() > 0 && data.text.size() <= 5000 &&
             data.authorId is string && data.authorId.size() > 0 &&
             data.authorName is string && data.authorName.size() > 0 &&
             (data.createdAt == request.time || data.createdAt is timestamp) &&
             // Optional fields
             (!data.keys().hasAny(['authorColor']) || data.authorColor is string) &&
             (!data.keys().hasAny(['updatedAt']) || (data.updatedAt == request.time || data.updatedAt is timestamp)) &&
             (!data.keys().hasAny(['isEdited']) || data.isEdited is bool) &&
             (!data.keys().hasAny(['isResolved']) || data.isResolved is bool);
    }
  }
}
